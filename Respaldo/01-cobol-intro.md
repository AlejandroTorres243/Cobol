# Sobre el COBOL

Cuando, en 1975, Edsger Dijkstra hizo su comentario de que "El uso de COBOL paraliza la mente. Su enseñanza debería, por lo tanto, considerarse un delito ", dio voz y consolidó la oposición a COBOL en el mundo académico. 
Esa oposición ha dado lugar a que cada vez menos instituciones académicas enseñen COBOL, de modo que ahora se ha hecho necesario programadores jóvenes que sustituyan a la envejecida mano de obra de COBOL.

Esta escasez está provocando una crisis de COBOL. A pesar de los comentarios de Dijkstra y las afirmaciones sobre la muerte inminente de COBOL, COBOL sigue siendo COBOL una fuerza dominante en el mundo de la informática empresarial, y los intentos de sustituir los sistemas COBOL heredados han demostrado ser difíciles, peligrosos y costosos. 

## Historia del COBOL

El origen de COBOL se remonta a abril de 1959, cuando tuvo lugar una reunión con expertos en informática, académicos, usuarios y fabricantes para discutir la creación de un lenguaje común, orientado a problemas, independiente de la máquina y diseñado específicamente para abordar las necesidades empresariales. El Departamento de Defensa de los Estados Unidos patrocinó y organizó el proyecto. COBOL se vio influenciado por varios lenguajes existentes, siendo los más significativos AIMACO (diseñado por la Fuerza Aérea de EE. UU.), FLOW-MATIC (desarrollado bajo la dirección de la Contralmirante Grace Hopper) y COMTRAN (el traductor comercial de IBM).

La primera definición de COBOL fue producida por el Comité de Lenguajes de Sistemas de Datos (CODASYL) en 1960. Dos fabricantes miembros del Comité, RCA y Remington-Rand-Univac, compitieron por producir el primer compilador de COBOL. El 6 y 7 de diciembre de 1960, el mismo programa COBOL (con cambios menores) se ejecutó en las computadoras de RCA y Remington-Rand-Univac.

Tras la definición inicial del lenguaje por parte del Comité CODASYL, la responsabilidad de desarrollar nuevos estándares de COBOL fue asumida por el Instituto Nacional de Estándares Estadounidenses (ANSI), que produjo los estándares ANS 68, ANS 74 y ANS 85. Actualmente, la Organización Internacional de Normalización (ISO) asume la responsabilidad de desarrollar nuevos estándares de COBOL. El estándar ISO 2002, la primera versión orientada a objetos de COBOL, fue definido por este organismo.

## Características clave de COBOL

**Enfoque Empresarial**: A diferencia de muchos otros lenguajes de programación de propósito general, COBOL está diseñado específicamente para aplicaciones empresariales. Está adaptado para manejar tareas como procesamiento de datos, manipulación de archivos y generación de informes comúnmente encontrados en entornos empresariales.

**Declaración y Manipulación de Datos Heterogéneos:** capaz de manejar datos empresariales diversos, incluyendo cadenas de caracteres de longitud fija, así como números enteros, cardinales y decimales.

**Soporte Nativo para Datos Decimales:** para aplicaciones financieras y contables, es esencial que el lenguaje admita cálculos precisos sin errores de redondeo, mediante el uso nativo de datos decimales.

**Capacidades de Generación de Informes:** el lenguaje facilita la creación de informes, una necesidad tradicional en aplicaciones empresariales.

**Acceso y Manipulación de Datos Orientados a Registros:** dado que las aplicaciones empresariales a menudo manejan datos orientados a registros almacenados en archivos y bases de datos, el lenguaje debería centrarse en el procesamiento externo de datos en lugar de estructuras de datos internas complejas.

**Limitaciones de COBOL**: Ausencia de acceso de bajo nivel, asignación dinámica de memoria y recursividad. Estas características son comunes en lenguajes utilizados para el desarrollo de juegos, programación de sistemas o aplicaciones algorítmicamente complejas.

**Desafíos Educativos**: COBOL no se enseña con frecuencia en los planes de estudio modernos de ciencias de la computación. Faltan ciertas características y constructos comúnmente utilizados para enseñar conceptos fundamentales de ciencias de la computación.

**Estructuras de Datos y Algoritmos**: COBOL no admite la creación de estructuras de datos avanzadas ni la implementación de algoritmos sofisticados. Como resultado, se eligen otros lenguajes de programación para fines educativos a fin de abordar un espectro más amplio de conceptos de ciencias de la computación.

**Restricciones del Plan de Estudios**: El pasaje menciona que los planes de estudio modernos de ciencias de la computación a menudo están abarrotados, lo que dificulta la introducción de múltiples lenguajes de programación. Dadas las percepciones de las limitaciones de COBOL en ciertas áreas, los educadores pueden optar por lenguajes que ofrezcan una introducción más completa a varios conceptos.


COBOL se adapta bien a estas características, diseñado específicamente con estas necesidades en mente. Además, sugiere que, a pesar de las deficiencias en estos aspectos, los lenguajes más modernos e independientes del dominio pueden carecer de fuerza en comparación con COBOL. 

En resumen, la importancia histórica de COBOL en la informática empresarial es evidente, pero sus limitaciones para abordar un rango más amplio de temas de ciencias de la computación contribuyen a su menor presencia en entornos educativos contemporáneos.

# Dificultad de cambiar COBOL por otros lenguajes

Hay varias razones por las cuales cambiar aplicaciones escritas en COBOL a otros lenguajes puede resultar difícil y desafiante:

1. **Complejidad y Tamaño del Código:** Las aplicaciones COBOL suelen ser extensas y complejas, con millones de líneas de código. La magnitud del código puede hacer que la migración sea un proyecto monumental.

2. **Lenguaje Específico para Negocios:** COBOL está diseñado específicamente para la programación de negocios y aplicaciones empresariales. Tiene constructos y funcionalidades que se adaptan bien a los requisitos y patrones de negocio. Cambiar a un lenguaje más general puede requerir modificaciones significativas en la lógica de negocio.

3. **Conformidad con Estándares y Normativas:** Muchas aplicaciones COBOL están enraizadas en estándares y normativas específicas de la industria, como regulaciones financieras o gubernamentales. Cambiar a otro lenguaje sin tener en cuenta estas normativas puede resultar en la pérdida de conformidad y generar problemas legales.

4. **Conocimiento Especializado:** La fuerza laboral con experiencia en COBOL puede ser escasa, pero es esencial para el mantenimiento y la evolución de las aplicaciones existentes. La falta de habilidades en otros lenguajes puede dificultar la transición.

5. **Integración con Sistemas Legados:** Las aplicaciones COBOL suelen estar integradas con sistemas propietarios, bases de datos y tecnologías específicas. La migración debe abordar estas integraciones para garantizar un funcionamiento fluido con otros sistemas.

6. **Fiabilidad y Estabilidad:** COBOL ha demostrado ser un lenguaje confiable y estable a lo largo de las décadas. Las aplicaciones en COBOL a menudo gestionan transacciones críticas para el negocio. Cambiar a un nuevo lenguaje introduce riesgos de estabilidad y confiabilidad.

7. **Costo y Recursos:** La migración de aplicaciones COBOL puede requerir una inversión significativa en términos de tiempo, recursos y costos. Esto incluye la capacitación del personal, la modificación del código existente y la validación exhaustiva para garantizar la funcionalidad adecuada.

8. **Resistencia al Cambio:** Las organizaciones pueden enfrentar resistencia al cambio debido a la percepción de que las aplicaciones COBOL funcionan bien y que una migración puede ser costosa y arriesgada.

En resumen, cambiar aplicaciones COBOL a otros lenguajes es un desafío multifacético que implica consideraciones técnicas, comerciales y de recursos. La decisión de migrar debe sopesar cuidadosamente los beneficios potenciales frente a los costos y riesgos asociados.


# Configuración del entorno en VSCode

* Instalar VSCOde y las extensiones IBM Z Open Editor y Zowe Explorer.
* Creación del perfil de acceso en Zowe Explorer
* Familiarizarse con los distintos tipos de objetos: ficheros "normales", particionados, fuentes, jcl, compilación y ejecución.

## Comandos zowe de instalación inicial

```
npm install -g @zowe/cli@zowe-v1-lts
zowe plugins install @zowe/secure-credential-store-for-zowe-cli@zowe-v1-lts
zowe profiles create zosmf learncobol --host 192.86.32.250 --port 10443 --ru false --user ZA9999 --pass prompt --ow
zowe profiles set zosmf learncobol
zowe scs update

```

## Copia de los programas con DB2

Seleccionar con  el filtro ZOS.PUBLIC y hacer submit al siguiente miembro el cual copiará en los ficheros del usuario todo lo necesario para testear COBOL con DB2.

```
ZOS.PUBLIC.DB2.JCL(DB2SETUP)
```
A continuación se habrá de ejecturar los siguientes miembros:
```
ZZ999.JCL(CRETBL)   -> crear tabla
ZZ999.JCL(LOADTBL)  -> cargar tabla
ZZ999.JCL(SELTBL)   -> comprobar datos
```


## Procedimientos JCL básicos.
1. Compile procedure (IGYWC) 
2. Compile and link-edit procedure (IGYWCL) 
3. Compile, link-edit, and run procedure (IGYWCLG)

[Documentación Jcl de IBM](https://www.ibm.com/docs/en/zos-basic-skills?topic=reusable-jcl-collection)
[Documentación COBOL de IBM](https://www.ibm.com/docs/en/cobol-zos/6.4)


## Ejemplo de comandos frecuentes zowe
```
zowe plugins list 
zowe files list ds "ZA999.*"
zowe files list data-set "HLQ.*"
zowe zos-jobs list jobs
zowe jobs submit ds "ZA999.JCL(HELLO)" --wait-for-output -rfj
zowe zos-files upload file-to-data-set "./local" "remoto" --zosmf-p profile
zowe files download am "ZA999.CBL" -e ".cbl"
zowe files download am "ZA999.JCL" -e ".jcl"
zowe jobs submit ds "Z99861.JCL(HELLO)" --vasc  toda la salida la vuelca al terminal
```

```
zowe jobs submit ds "Z99861.JCL(HELLO)" --wfo 
jobid:   JOB00293
retcode: CC 0000
jobname: HELLOCBL
status:  OUTPUT

zowe jobs list sfbj JOB00293                  
2   JESMSGLG       JES2  
3   JESJCL         JES2  
4   JESYSMSG       JES2  
101 SYSPRINT COBOL COBRUN
102 SYSPRINT LKED  COBRUN
104 SYSOUT   GO    COBRUN

zowe jobs view sfbi JOB00293 104    
 HELLO WORLD!

zowe jobs submit ds "Z99861.JCL(HELLO)" -d .   
jobid:   JOB00296
retcode: CC 0000
jobname: HELLOCBL
status:  OUTPUT
Successfully downloaded output to ././JOB00296
```

# Uso de zowe con javascript

En la carpeta zowejs hay un ejemplo de cómo crear automatizaciones con zowe y node.js

```
npm run submitJob "ZA999.JCL(MIJCL)" 4

```


